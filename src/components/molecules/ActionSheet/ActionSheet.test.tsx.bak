import { render, screen, fireEvent, waitFor, act } from '@testing-library/react'
import { axe } from 'jest-axe'
import { ActionSheet, type ActionSheetProps, type Action } from './ActionSheet'

describe('ActionSheet', () => {
  const mockActions: Action[] = [
    {
      id: '1',
      label: 'Edit',
      icon: 'edit',
      onSelect: jest.fn()
    },
    {
      id: '2',
      label: 'Share',
      icon: 'share',
      onSelect: jest.fn()
    },
    {
      id: '3',
      label: 'Delete',
      icon: 'trash',
      destructive: true,
      onSelect: jest.fn()
    }
  ]
  
  const defaultProps: ActionSheetProps = {
    isOpen: true,
    onClose: jest.fn(),
    actions: mockActions
  }
  
  const renderActionSheet = (props: Partial<ActionSheetProps> = {}) => {
    return render(<ActionSheet {...defaultProps} {...props} />)
  }
  
  // Mock scrollIntoView
  beforeEach(() => {
    Element.prototype.scrollIntoView = jest.fn()
  })
  
  afterEach(async () => {
    jest.clearAllMocks()
    await act(async () => {
      document.body.innerHTML = ''
    })
  })
  
  describe('Basic Rendering', () => {
    it('renders action sheet when open', () => {
      renderActionSheet()
      expect(screen.getByRole('dialog')).toBeInTheDocument()
    })
    
    it('does not render when closed', () => {
      renderActionSheet({ isOpen: false })
      expect(screen.queryByRole('dialog')).not.toBeInTheDocument()
    })
    
    it('renders title when provided', () => {
      renderActionSheet({ title: 'Choose an action' })
      expect(screen.getByText('Choose an action')).toBeInTheDocument()
    })
    
    it('renders description when provided', () => {
      renderActionSheet({ title: 'Actions', description: 'Select an action to perform' })
      expect(screen.getByText('Select an action to perform')).toBeInTheDocument()
    })
    
    it('renders all actions', () => {
      renderActionSheet()
      expect(screen.getByText('Edit')).toBeInTheDocument()
      expect(screen.getByText('Share')).toBeInTheDocument()
      expect(screen.getByText('Delete')).toBeInTheDocument()
    })
    
    it('renders action icons', () => {
      renderActionSheet()
      // Icons are present in the document
      const buttons = screen.getAllByRole('button')
      expect(buttons.length).toBeGreaterThan(0)
    })
    
    it('renders close button by default', () => {
      renderActionSheet({ title: 'Actions' })
      expect(screen.getByLabelText('Close')).toBeInTheDocument()
    })
    
    it('hides close button when showCloseButton is false', () => {
      renderActionSheet({ title: 'Actions', showCloseButton: false })
      expect(screen.queryByLabelText('Close')).not.toBeInTheDocument()
    })
    
    it('applies data-testid', () => {
      renderActionSheet({ 'data-testid': 'action-sheet-test' })
      expect(screen.getByTestId('action-sheet-test')).toBeInTheDocument()
    })
  })
  
  describe('Action Interactions', () => {
    it('calls onSelect when action is clicked', async () => {
      await renderActionSheet()
      
      const editButton = screen.getByText('Edit')
      fireEvent.click(editButton)
      
      expect(mockActions[0].onSelect).toHaveBeenCalledTimes(1)
    })
    
    it('calls onClose after action is selected', async () => {
      const onClose = jest.fn()
      await renderActionSheet({ onClose })
      
      const editButton = screen.getByText('Edit')
      fireEvent.click(editButton)
      
      expect(onClose).toHaveBeenCalledTimes(1)
    })
    
    it('does not call onSelect for disabled action', async () => {
      const disabledAction: Action = {
        id: '4',
        label: 'Disabled',
        disabled: true,
        onSelect: jest.fn()
      }
      
      await renderActionSheet({ actions: [disabledAction] })
      
      const button = screen.getByText('Disabled')
      fireEvent.click(button)
      
      expect(disabledAction.onSelect).not.toHaveBeenCalled()
    })
    
    it('renders disabled action with disabled attribute', async () => {
      const disabledAction: Action = {
        id: '4',
        label: 'Disabled',
        disabled: true,
        onSelect: jest.fn()
      }
      
      await renderActionSheet({ actions: [disabledAction] })
      
      const button = screen.getByText('Disabled').closest('button')
      expect(button).toBeDisabled()
    })
  })
  
  describe('Destructive Actions', () => {
    it('renders destructive action with special styling', async () => {
      await renderActionSheet()
      
      const deleteButton = screen.getByText('Delete')
      expect(deleteButton).toBeInTheDocument()
    })
    
    it('adds divider before destructive action', async () => {
      await renderActionSheet()
      
      // Divider is rendered before the destructive action
      const container = screen.getByRole('dialog')
      expect(container).toBeInTheDocument()
    })
    
    it('handles multiple destructive actions', async () => {
      const actions: Action[] = [
        { id: '1', label: 'Edit', onSelect: jest.fn() },
        { id: '2', label: 'Delete', destructive: true, onSelect: jest.fn() },
        { id: '3', label: 'Remove', destructive: true, onSelect: jest.fn() }
      ]
      
      await renderActionSheet({ actions })
      
      expect(screen.getByText('Delete')).toBeInTheDocument()
      expect(screen.getByText('Remove')).toBeInTheDocument()
    })
  })
  
  describe('Close Interactions', () => {
    it('calls onClose when close button is clicked', async () => {
      const onClose = jest.fn()
      await renderActionSheet({ title: 'Actions', onClose })
      
      const closeButton = screen.getByLabelText('Close')
      fireEvent.click(closeButton)
      
      expect(onClose).toHaveBeenCalledTimes(1)
    })
    
    it('closes on Escape key when closeOnEscape=true', async () => {
      const onClose = jest.fn()
      await renderActionSheet({ onClose, closeOnEscape: true })
      
      fireEvent.keyDown(document, { key: 'Escape' })
      
      expect(onClose).toHaveBeenCalledTimes(1)
    })
    
    it('does not close on Escape when closeOnEscape=false', async () => {
      const onClose = jest.fn()
      await renderActionSheet({ onClose, closeOnEscape: false })
      
      fireEvent.keyDown(document, { key: 'Escape' })
      
      expect(onClose).not.toHaveBeenCalled()
    })
  })
  
  describe('Focus Management', () => {
    it('focuses first button when opened', async () => {
      await renderActionSheet()
      
      await waitFor(() => {
        const firstButton = screen.getByText('Edit')
        expect(firstButton).toHaveFocus()
      })
    })
    
    it('prevents body scroll when open', async () => {
      const originalOverflow = document.body.style.overflow
      
      await renderActionSheet()
      
      expect(document.body.style.overflow).toBe('hidden')
      
      // Cleanup
      document.body.style.overflow = originalOverflow
    })
  })
  
  describe('ARIA Attributes', () => {
    it('has role="dialog"', async () => {
      await renderActionSheet()
      expect(screen.getByRole('dialog')).toBeInTheDocument()
    })
    
    it('has aria-modal="true"', async () => {
      await renderActionSheet()
      const dialog = screen.getByRole('dialog')
      expect(dialog).toHaveAttribute('aria-modal', 'true')
    })
    
    it('has aria-labelledby when title is provided', async () => {
      await renderActionSheet({ title: 'Choose an action' })
      const dialog = screen.getByRole('dialog')
      expect(dialog).toHaveAttribute('aria-labelledby', 'action-sheet-title')
    })
    
    it('has aria-describedby when description is provided', async () => {
      await renderActionSheet({ title: 'Actions', description: 'Select an action' })
      const dialog = screen.getByRole('dialog')
      expect(dialog).toHaveAttribute('aria-describedby', 'action-sheet-description')
    })
    
    it('action buttons have aria-label', async () => {
      await renderActionSheet()
      const editButton = screen.getByLabelText('Edit')
      expect(editButton).toBeInTheDocument()
    })
  })
  
  describe('Accessibility', () => {
    it('should have no accessibility violations in default state', async () => {
      const { container } = renderActionSheet()
      await waitFor(async () => {
        const results = await axe(container)
        expect(results).toHaveNoViolations()
      })
    }, 10000)
    
    it('should have no accessibility violations with title and description', async () => {
      const { container } = renderActionSheet({
        title: 'Choose an action',
        description: 'Select one of the following actions'
      })
      await waitFor(async () => {
        const results = await axe(container)
        expect(results).toHaveNoViolations()
      })
    }, 10000)
    
    it('should have no accessibility violations with disabled action', async () => {
      const actions: Action[] = [
        { id: '1', label: 'Enabled', onSelect: jest.fn() },
        { id: '2', label: 'Disabled', disabled: true, onSelect: jest.fn() }
      ]
      
      const { container } = renderActionSheet({ actions })
      await waitFor(async () => {
        const results = await axe(container)
        expect(results).toHaveNoViolations()
      })
    }, 10000)
  })
  
  describe('Edge Cases', () => {
    it('handles empty actions array', async () => {
      await renderActionSheet({ actions: [] })
      const dialog = screen.getByRole('dialog')
      expect(dialog).toBeInTheDocument()
    })
    
    it('handles single action', async () => {
      const singleAction: Action[] = [
        { id: '1', label: 'Only Action', onSelect: jest.fn() }
      ]
      
      await renderActionSheet({ actions: singleAction })
      expect(screen.getByText('Only Action')).toBeInTheDocument()
    })
    
    it('handles action without icon', async () => {
      const actionNoIcon: Action[] = [
        { id: '1', label: 'No Icon', onSelect: jest.fn() }
      ]
      
      await renderActionSheet({ actions: actionNoIcon })
      expect(screen.getByText('No Icon')).toBeInTheDocument()
    })
    
    it('handles very long action labels', async () => {
      const longLabel = 'This is a very long action label that might wrap to multiple lines'
      const actions: Action[] = [
        { id: '1', label: longLabel, onSelect: jest.fn() }
      ]
      
      await renderActionSheet({ actions })
      expect(screen.getByText(longLabel)).toBeInTheDocument()
    })
    
    it('renders in portal (not in parent component tree)', async () => {
      const result = await renderActionSheet()
      
      // Dialog should be in document.body, not in the container
      expect(result.container.querySelector('[role="dialog"]')).not.toBeInTheDocument()
      expect(document.body.querySelector('[role="dialog"]')).toBeInTheDocument()
    })
  })
})
